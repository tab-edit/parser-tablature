@precedence { aggregate @left }

@top Tablature {
    (
        ( TabSegment (newline|eof) ) | newline
    )+
}


RepeatLine {
    Repeat+
}
Repeat {
    delim dash+
    repeatText
    dash+ delim
}
@skip {} {
    repeatText {
        "repeat" " "+ Multiplier
    }
    TimeSignature {
        number "/" number
    }
}

TimeSigLine {
    TimeSignature+
}
TimingLine {
    "XQ" "e."+
}

TabSegment {
    // (RepeatLine newline)?
    (TimeSigLine newline)?
    (TabSegmentLine (newline|eof))+
    (TimingLine (newline|eof))?
}

TabSegmentLine { 
    TabString+
}

// NamelessMeasureStart { delim }
// TODO: make TabString start with (MeasureLineName|NamelessMeasureStart). this introduces a lot of bugs you have to deal with tho (you have to think of how you separate two TabStrings on the same line. it may involve you inverting the skip sets - i.e. skip spaces only inside of MeasureLines and between TabSections. this is probably a better design anyway, so i will also include it as its own TODO)
// TODO: invert the skip sets - i.e. skip spaces only inside of MeasureLines and between TabSections. the rest will strictly obey no spacing. this is better design than what we currently have
// TODO: capture the starting delimiter of a measureline within the measureline itself by doing: (delim|dash) !aggregate in the MeasureLine rule
TabString {
    ( 
        (MeasureLineName (delim|dash)) | 
        delim
    )
    MeasureLine+
    Multiplier?
}
MeasureLine {
    (dash+ measureLineEnd) |
    (dash* measureComponent+ measureLineEnd)
}
measureLineEnd {
    inlineRepeat | delim
}

//TODO: create an external token called InsertMeasureLineName so that we can know where missing measure line names are and make linting rules easily based on that

// -----Measure components like fret, e.t.c.---------------
measureComponent { stringComponent } // in the future, "stringComponent | percussionComponent"
stringComponent {
    Hammer |
    Pull |
    Slide |
    atomicStringComponent dash*
}

Fret[@isGroup=MeasureComponent] { number }
Harmonic[@isGroup=MeasureComponent] { "[" Fret "]" }
Grace[@isGroup=MeasureComponent] { graceSym Fret }
atomicStringComponent {
    Fret | Harmonic | Grace
}

Hammer[@isGroup=NoteConnector] { measureComponentConnector<hammerSym> }
Pull[@isGroup=NoteConnector] { measureComponentConnector<pullSym> }
Slide[@isGroup=NoteConnector] { measureComponentConnector<slideSym> }
measureComponentConnector<connector> {
    atomicStringComponent dash*
    connector
    stringComponent
}

inlineRepeat { "*" delimChar delimChar }
Multiplier { (x number) | (number x) | (number "times") }
// ---------------------------------------------------------
@skip { " " | Tab | Comment }
Tab { "\t" }
@tokens {
    dash { "-" }
    delimChar { $[|:] }
    delim { delimChar delimChar? }
    newline { "\r"?"\n" }

    Comment { "#" ![\n\r]* }
    slideSym { $[s/\\] }
    hammerSym { $[hH] }
    pullSym { $[pP] }
    
    x { $[xX] }
    MeasureLineName { $[eE] | $[bB] | $[gG] | $[dD] | $[aA] }
}

@external tokens endOfFile from "./tokens" { eof }
@external tokens measureComponentExternTokens from "./tokens" { graceSym }
@external tokens numberToken from "./tokens" { number }